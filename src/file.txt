def int f(int[] a,float[] c){
   int b = 3*12+3+1;
   return 10;
}

{

}
a = a;


string s = "ok\" ok";
string s1 ="";

{
    int a = 10+(15*2) + b(1,12+3);
    string s = null;
    int[10+10] array;
    return 10;
}

def int f(int[] a,float[] c){
   int b = 3*12+3;
   return 10;
}

while (True) {
    print("p");
    string s = print("feed me");
    string s = 1.1;
}

if (True) print("OK"); else if(False) input("NOPE");

/*
Bottom-up parsing was driven by tables which made the algorithm fast for correct inputs, but unable to accurately diagnose faulty ones.
The subset of grammars parsed was still not quite large enough, even for conservative language designers.
And bottom-up parsing was very unfriendly to custom hacks, which made every shortcoming loom large.
It is much harder to work around a problem in a bottom-up parser than than it is to deal with a similar shortcoming in a top-down parser.
After decades of experience with bottom-up parsing, top-down parsing has re-emerged as the algorithm of choice.
*/