def int f(int[] a,float[] c){
   int b = 3*12+3+1;
   return 10;
}

{

}
a = a;


string s = "ok\" ok";
string s1 ="";

{
    int a = 10+(15*2) + b(1,12+3);
    string s = null;
    int[10+10] array;
    return 10;
    if (True){
        print("OK")
    }
}

def int f(int[] a,float[] c){
   int b = 3*12+3;
   return 10;
}

while (True) {
    print("p");
    string s = print("feed me");
    string s = 1.1;
}

if (True) print("OK"); else if(False) input("NOPE");
if (False){
    print("nope");
} else if (1==1){
    print("Ok");
}

/*
Bottom-up parsing was driven by tables which made the algorithm fast for correct inputs, but unable to accurately diagnose faulty ones.
The subset of grammars parsed was still not quite large enough, even for conservative language designers.
And bottom-up parsing was very unfriendly to custom hacks, which made every shortcoming loom large.
It is much harder to work around a problem in a bottom-up parser than than it is to deal with a similar shortcoming in a top-down parser.
After decades of experience with bottom-up parsing, top-down parsing has re-emerged as the algorithm of choice.
*/
/*
Block:0B
 LABEL 0B;
 LOAD _t0 ['INTEGER_CONST', 0];
 INIT ['INT', 'val'] _t0;
 CALLBLOCK 0B0B;
 LABEL E0B;

Block:0B0B
 LOAD _t0 ['INTEGER_CONST', 0];
 INIT ['INT', 'i'] _t0;
 LABEL 0B0B;
 LOAD _t0 i;
 LOAD _t1 ['INTEGER_CONST', 10];
 LESS _t0 _t1;
 JUMPZ _t0 E0B0B;
 CALLBLOCK 0B0B0B;
 LABEL C0B0B;
 LOAD _t0 ['INTEGER_CONST', 1];
 ASSIGNPLUS i _t0;
 JUMPBLOCK 0B0B;
 LABEL E0B0B;

Block:0B0B0B
 LOAD _t0 ['INTEGER_CONST', 0];
 INIT ['INT', 'j'] _t0;
 LABEL 0B0B0B;
 LOAD _t0 j;
 LOAD _t1 ['INTEGER_CONST', 10];
 LESS _t0 _t1;
 JUMPZ _t0 E0B0B0B;
 LOAD _t0 ['INTEGER_CONST', 1];
 ASSIGNPLUS val _t0;
 LABEL C0B0B0B;
 LOAD _t0 ['INTEGER_CONST', 1];
 ASSIGNPLUS j _t0;
 JUMPBLOCK 0B0B0B;
 LABEL E0B0B0B;
 */